<script>
/** ====== CONFIG ====== **/
const PICKUP_API = "http://localhost:3000/api/pickup"; // your API
const VARIANT_ID  = "46578436571392";                  // can be replaced by Liquid
const DEFAULT_PRODUCT_ID = '{{ cart.items.first.product.id }}';
const SHOP_DOMAIN = '{{shop.domain}}';

/** ====== DOM ====== **/
const deliveryMethods = document.querySelectorAll('.delivery-method');
const postcodeLabel   = document.getElementById('postcode-label');
const postcodeInput   = document.getElementById('postcode-input');
const searchButton    = document.getElementById('search-button');
const checkoutSection = document.getElementById('checkout-section');
const checkoutButton  = document.querySelector('.checkout-button');
const optionsSection  = document.getElementById('options-section');
const locationSection = document.getElementById('location-section');
const authorityCheckbox = document.getElementById('authority-checkbox');
const loading         = document.getElementById('loading');
const locationsList   = document.getElementById('locations-list');

/** ====== STATE ====== **/
let selectedMethod = 'collect';
let selectedLocationId = null;
let hasSearched = false;
let customerCoords = null;

/** ====== HELPERS ====== **/
function calculateDistance(lat1, lon1, lat2, lon2) {
  if ([lat1, lon1, lat2, lon2].some(v => v == null)) return null;
  const R = 6371;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2)**2 +
            Math.cos(lat1*Math.PI/180) * Math.cos(lat2*Math.PI/180) *
            Math.sin(dLon/2)**2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return +(R*c).toFixed(0); // km, rounded
}

function formatAddressFromAPI(addr){
  // Create an array like your UI expects (joined by <br>)
  const line1 = [addr?.address1, addr?.address2].filter(Boolean).join(', ');
  const line2 = [addr?.city, addr?.province].filter(Boolean).join(', ');
  const line3 = [addr?.country, addr?.zip].filter(Boolean).join(' - ');
  return [line1, line2, line3].filter(Boolean);
}

/** ====== GEO ====== **/
async function getCustomerLocation() {
  return new Promise((resolve) => {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        pos => resolve({ latitude: pos.coords.latitude, longitude: pos.coords.longitude }),
        ()  => resolve({ latitude: 30.7333, longitude: 76.7794 }) // Chandigarh fallback
      );
    } else {
      resolve({ latitude: 30.7333, longitude: 76.7794 });
    }
  });
}

/** ====== INIT ====== **/
async function init() {
  customerCoords = await getCustomerLocation();
  updateInterface();
  addEventListeners();
}

function addEventListeners() {
  deliveryMethods.forEach(method => {
    method.addEventListener('click', () => {
      deliveryMethods.forEach(m => m.classList.remove('active'));
      method.classList.add('active');

      selectedMethod = method.dataset.method;
      hasSearched = false;
      selectedLocationId = null;

      setTimeout(() => {
        const checkoutButton1 = document.querySelector('#checkout');
        if (checkoutButton1) {
          checkoutButton1.disabled = false;
          checkoutButton1.classList.add('enabled');
        }
      }, 3000);

      updateInterface();
    });
  });

  authorityCheckbox?.addEventListener('click', () => {
    authorityCheckbox.classList.toggle('checked');
  });

  searchButton.addEventListener('click', searchLocations);
  postcodeInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') searchLocations();
  });

  // row select handler (kept from your code)
  document.addEventListener("click", function (e) {
    const selectedItem = e.target.closest(".location-item");
    if (selectedItem) {
      document.querySelectorAll(".location-item").forEach(item => item.classList.remove("selected"));
      selectedItem.classList.add("selected");

      const checkoutBtn = document.getElementById("checkout");
      if (!checkoutBtn) return;

      if (selectedItem.querySelector(".sdev-stock-status").classList.contains("out-of-stock")) {
        checkoutBtn.disabled = true;
        checkoutBtn.classList.add("disabled");
      } else {
        checkoutBtn.disabled = false;
        checkoutBtn.classList.remove("disabled");
      }
    }
  });
}

function updateInterface() {
  if (selectedMethod === 'collect') {
    postcodeLabel.textContent = 'Search for a location to pick up your order:';
    postcodeInput.placeholder = 'Enter Postcode';

    if (hasSearched) {
      setTimeout(() => {
        const checkoutButton1 = document.querySelector('#checkout');
        if (checkoutButton1) {
          checkoutButton1.disabled = false;
          checkoutButton1.classList.add('enabled');
        }
      }, 5000);
      optionsSection.classList.remove('show');
      locationSection.classList.add('active');
    } else {
      checkoutSection.style.display = 'none';
      optionsSection.classList.remove('show');
      locationSection.classList.remove('active');
    }
  } else {
    postcodeLabel.textContent = 'Enter postcode for postage estimate:';
    postcodeInput.placeholder = '3000';
    checkoutSection.style.display = 'none';
    optionsSection.classList.add('show');
    locationSection.classList.remove('active');
  }
  updateCheckoutButtonState();
}

/** ====== SEARCH (uses /api/pickup) ====== **/
async function searchLocations() {
  const postcode = postcodeInput.value.trim();
  if (!postcode) {
    alert('Please enter a postcode');
    return;
  }

  if (selectedMethod === 'collect') {
    hasSearched = true;
    updateInterface();
    await loadPickupFromAPI(postcode);
  } else {
    console.log('Searching delivery options for postcode:', postcode);
  }
}

/** ====== FETCH & MAP YOUR API ====== **/
async function loadPickupFromAPI(postcode) {
  showLoading();
  locationsList.innerHTML = '';

  try {
    const body = JSON.stringify({
      pincode: postcode,
      variantId: VARIANT_ID,
      radiusKm: 100
    });

    const res = await fetch(PICKUP_API, {
      method: 'POST',
      headers: { 'Content-Type':'application/json' },
      body
    });

    if (!res.ok) throw new Error('Pickup API error');
    const data = await res.json();

    // Merge inRadius and outOfRadius to one list (nearest first)
    const merged = [...(data.inRadius || []), ...(data.outOfRadius || [])];

    // Normalize to what your renderer expects
    const normalized = merged.map(loc => {
      const formatted = formatAddressFromAPI(loc.address);
      const distKm = loc.distanceKm ?? (
        customerCoords ? calculateDistance(
          customerCoords.latitude, customerCoords.longitude,
          loc.coordinates?.lat, loc.coordinates?.lng
        ) : null
      );
      return {
        id: loc.locationId,
        name: loc.name,
        distance: distKm, // number | null
        status: String(loc.status || '').toLowerCase(), // 'instock' | 'out_of_stock'
        address: { formatted }, // keep same structure your UI uses
        raw: loc
      };
    });

    displayLocations(normalized);

  } catch (err) {
    console.error(err);
    showError('Failed to load stock information. Please try again.');
  } finally {
    hideLoading();
  }
}

/** ====== RENDER ====== **/
function displayLocations(locations) {
  locationsList.innerHTML = '';

  if (!locations.length) {
    locationsList.innerHTML = `
      <div class="no-results">
        <p>No locations found for the entered postcode.</p>
      </div>`;
    return;
  }

  // sort by distance when available
  locations.sort((a,b)=>{
    if (a.distance == null && b.distance == null) return 0;
    if (a.distance == null) return 1;
    if (b.distance == null) return -1;
    return a.distance - b.distance;
  });

  locations.forEach((location, idx) => {
    const el = createLocationElement(location);
    locationsList.appendChild(el);

    // Select first in-stock by default
    if (idx === 0 && location.status === 'instock') {
      el.classList.add('selected');
      selectedLocationId = location.id;
    }
  });
}

function createLocationElement(location) {
  const div = document.createElement('div');

  const isInStock = location.status === 'instock';
  const stockStatusClass = isInStock ? '' : 'out-of-stock';
  const stockStatusText  = isInStock ? 'In stock' : 'Out of stock';

  div.className = `location-item ${stockStatusClass}`;
  div.dataset.locationId = location.id;

  const distanceStr = (location.distance != null) ? `${location.distance} km` : '';

  div.innerHTML = `
    <div class="sdev-location-header">
      <div class="sdev-location-name">
        <div class="sdev-location-selector"></div>
        ${location.name}
        <span class="sdev-location-distance">${distanceStr}</span>
      </div>
      <div class="sdev-stock-status ${stockStatusClass}">
        <div class="sdev-stock-indicator"></div>
        ${stockStatusText}
      </div>
    </div>
    <div class="addressed_click_cmt">
      <div class="sdev-location-address">
        ${location.address.formatted.join('<br>')}
      </div>
    </div>
  `;

  // Click to select + expand (matches your CSS)
  div.addEventListener('click', () => {
    document.querySelectorAll('.location-item').forEach(item => item.classList.remove('selected'));
    div.classList.add('selected');
    selectedLocationId = location.id;

    addToCartWithLocation(location);
    updateCheckoutButtonState();
  });

  return div;
}

/** ====== CART TAGGING (kept) ====== **/
function addToCartWithLocation(location) {
  const data = {
    id: "46950237503744", // your meta item / variant used to carry pickup info
    quantity: 1,
    properties: {
      Address: `${location.address.formatted.join(', ')}`,
      'Pickup Location': location.name,
      'Location ID': location.id
    }
  };

  fetch('/cart/add.js', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data)
  })
  .then(r => r.json())
  .then(() => {
    console.log('Item added to cart with location:', location.name);
    localStorage.setItem("lastAddedVariant", '46950237503744');
  })
  .catch(err => console.error('Error adding item to cart:', err));
}

/** ====== UI UTILS ====== **/
function showLoading(){ loading.classList.remove('hidden'); locationsList.innerHTML=''; }
function hideLoading(){ loading.classList.add('hidden'); }
function showError(message){
  locationsList.innerHTML = `<div class="error-message"><p>${message}</p></div>`;
}

function updateCheckoutButtonState() {
  if (selectedMethod === 'collect') {
    if (selectedLocationId !== null && hasSearched) {
      checkoutButton.classList.add('enabled');
      checkoutButton.disabled = false;
    } else {
      checkoutButton.classList.remove('enabled');
      checkoutButton.disabled = false;
    }
  } else {
    checkoutButton.classList.add('enabled');
    checkoutButton.disabled = false;
  }
}

/** ====== LIFECYCLE ====== **/
document.addEventListener('DOMContentLoaded', init);

// remove the meta item when leaving (kept)
window.addEventListener("beforeunload", function () {
  const targetVariantId = "46950237503744";
  fetch('/cart.js')
    .then(res => res.json())
    .then(cart => {
      const updates = {};
      cart.items.forEach(item => {
        if (item.variant_id == targetVariantId) updates[item.key] = 0;
      });
      if (Object.keys(updates).length > 0) {
        return fetch('/cart/update.js', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ updates })
        });
      }
    })
    .catch(err => console.error("Error removing target item:", err));
});

// refresh if that meta item was just added (kept)
if (localStorage.getItem("lastAddedVariant") === "46950237503744") {
  localStorage.removeItem("lastAddedVariant");
  setTimeout(() => {
    window.location.href = window.location.href.split('#')[0] + '?reload=' + new Date().getTime();
  }, 2000);
}
</script>
